
static INLINE boolean
d3d11_to_pipe_box(struct pipe_box *dst, D3D11_BOX *src)
{
    if (src->left >= src->right ||
        src->top >= src->bottom ||
        src->front >= src->back)
        return FALSE;
    dst->x = src->left;
    dst->y = src->top;
    dst->z = src->front;
    dst->width = src->right - src->left;
    dst->height = src->bottom - src->top;
    dst->depth = src->back - src->front;
    return TRUE;
}

static INLINE unsigned
d3d11_subresource_to_level(struct pipe_resource *res, UINT sr)
{
    
}

static INLINE unsigned
d3d11_to_pipe_usage(D3D11_USAGE usage)
{
    switch (usage) {
    case D3D11_USAGE_DEFAULT: return PIPE_USAGE_DEFAULT;
    case D3D11_USAGE_IMMUTABLE: return PIPE_USAGE_IMMUTABLE;
    case D3D11_USAGE_DYNAMIC: return PIPE_USAGE_STREAM;
    case D3D11_USAGE_STAGING: return PIPE_USAGE_STAGING;
    default:
        assert(!"invalid D3D_USAGE");
        return PIPE_USAGE_DEFAULT;
    }
}

static INLINE unsigned
d3d11_usage_to_pipe_bind(D3D11_USAGE usage)
{
    switch (usage) {
    case D3D11_USAGE_DEFAULT: return PIPE_BIND_SAMPLER_VIEW;
    case D3D11_USAGE_IMMUTABLE: return PIPE_BIND_SAMPLER_VIEW;
    case D3D11_USAGE_DYNAMIC: return PIPE_BIND_TRANSFER_WRITE | PIPE_BIND_SAMPLER_VIEW;
    case D3D11_USAGE_STAGING: return PIPE_BIND_TRANSFER_WRITE | PIPE_BIND_TRANSFER_READ;
    default:
        assert(!"invalid D3D_USAGE");
        return 0;
    }
}

static INLINE unsigned
d3d11_to_pipe_bind(D3D11_BIND_FLAG bind)
{
    unsigned pipe = 0;

    if (bind & D3D11_BIND_VERTEX_BUFFER)    bind |= PIPE_BIND_VERTEX_BUFFER;
    if (bind & D3D11_BIND_INDEX_BUFFER)     bind |= PIPE_BIND_INDEX_BUFFER;
    if (bind & D3D11_BIND_CONSTANT_BUFFER)  bind |= PIPE_BIND_CONSTANT_BUFFER;
    if (bind & D3D11_BIND_SHADER_RESOURCE)  bind |= PIPE_BIND_SHARED;
    if (bind & D3D11_BIND_STREAM_OUTPUT)    bind |= PIPE_BIND_STREAM_OUTPUT;
    if (bind & D3D11_BIND_RENDER_TARGET)    bind |= PIPE_BIND_RENDER_TARGET;
    if (bind & D3D11_BIND_DEPTH_STENCIL)    bind |= PIPE_BIND_DEPTH_STENCIL;
    if (bind & D3D11_BIND_UNORDERED_ACCESS)
        bind |= PIPE_BIND_SHADER_RESOURCE | PIPE_BIND_COMPUTE_RESOURCE;

    return pipe;
}

static INLINE unsigned
d3d11_cpu_access_flags_to_pipe_bind(D3D11_CPU_ACCESS_FLAG flags)
{
    unsigned pipe = 0;

    if (flags & D3D11_CPU_ACCESS_WRITE) pipe  = PIPE_BIND_TRANSFER_WRITE;
    if (flags & D3D11_CPU_ACCESS_READ)  pipe |= PIPE_BIND_TRANSFER_READ;

    return pipe;
}

static INLINE unsigned
d3d11_misc_flags_to_pipe_bind(D3D11_RESOURCE_MISC_FLAG flags)
{
    unsigned pipe = 0;

    if (flags & D3D11_RESOURCE_MISC_SHARED) pipe |= PIPE_BIND_SHARED;

    return pipe;
}

#define D3D11_LOGIC_OP_CASE(n) case D3D11_LOGIC_OP_##n: return PIPE_LOGICOP_##n
static INLINE unsigned
d3d11_to_pipe_logic_op(D3D11_LOGIC_OP op)
{
    switch (op) {
    D3D11_LOGIC_OP_CASE(NOOP);
    D3D11_LOGIC_OP_CASE(CLEAR);
    D3D11_LOGIC_OP_CASE(SET);
    D3D11_LOGIC_OP_CASE(INVERT);
    D3D11_LOGIC_OP_CASE(EQUIV);
    D3D11_LOGIC_OP_CASE(COPY);
    D3D11_LOGIC_OP_CASE(COPY_INVERTED);
    D3D11_LOGIC_OP_CASE(NAND);
    D3D11_LOGIC_OP_CASE(NOR);
    D3D11_LOGIC_OP_CASE(XOR);
    D3D11_LOGIC_OP_CASE(AND);
    D3D11_LOGIC_OP_CASE(AND_REVERSE);
    D3D11_LOGIC_OP_CASE(AND_INVERTED);
    D3D11_LOGIC_OP_CASE(OR);
    D3D11_LOGIC_OP_CASE(OR_REVERSE);
    D3D11_LOGIC_OP_CASE(OR_INVERTED);
    default:
        assert(!"invalid D3D11_LOGIC_OP");
        return PIPE_LOGICOP_NOOP;
    }
}
#undef D3D11_LOGIC_OP_CASE

#define D3D11_BLEND_CASE(n, m) case D3D11_BLEND_##n: return PIPE_BLENDFACTOR_##m
static INLINE unsigned
d3d11_to_pipe_blend_factor(D3D11_BLEND blend)
{
    switch (blend) {
    D3D11_BLEND_CASE(ZERO, ZERO);
    D3D11_BLEND_CASE(ONE, ONE);
    D3D11_BLEND_CASE(BLEND_FACTOR, CONST_COLOR);
    D3D11_BLEND_CASE(INV_BLEND_FACTOR, INV_CONST_COLOR);
    D3D11_BLEND_CASE(SRC_COLOR, SRC_COLOR);
    D3D11_BLEND_CASE(SRC_ALPHA, SRC_ALPHA);
    D3D11_BLEND_CASE(SRC_ALPHA_SAT, SRC_ALPHA_SATURATE);
    D3D11_BLEND_CASE(DEST_COLOR, DST_COLOR);
    D3D11_BLEND_CASE(DEST_ALPHA, DST_ALPHA);
    D3D11_BLEND_CASE(SRC1_COLOR, SRC1_COLOR);
    D3D11_BLEND_CASE(SRC1_ALPHA, SRC1_ALPHA);
    D3D11_BLEND_CASE(INV_SRC_COLOR, INV_SRC_COLOR);
    D3D11_BLEND_CASE(INV_SRC_ALPHA, INV_SRC_ALPHA);
    D3D11_BLEND_CASE(INV_DEST_ALPHA, INV_DST_ALPHA);
    D3D11_BLEND_CASE(INV_DEST_COLOR, INV_DST_COLOR);
    D3D11_BLEND_CASE(INV_SRC1_COLOR, INV_SRC1_COLOR);
    D3D11_BLEND_CASE(INV_SRC1_ALPHA, INV_SRC1_ALPHA);
    default:
       assert(!"invalid D3D11_BLEND");
       return PIPE_BLENDFACTOR_ZERO;
    }
}
#undef D3D11_BLEND_CASE

static INLINE unsigned
d3d11_to_pipe_blend_op(D3D11_BLEND_OP op)
{
   switch (op) {
   case D3D11_BLEND_OP_ADD: return PIPE_BLEND_ADD;
   case D3D11_BLEND_OP_SUBTRACT: return PIPE_BLEND_SUBTRACT;
   case D3D11_BLEND_OP_REV_SUBTRACT: return PIPE_BLEND_REVERSE_SUBTRACT;
   case D3D11_BLEND_OP_MIN: return PIPE_BLEND_MIN;
   case D3D11_BLEND_OP_MAX: return PIPE_BLEND_MAX;
   default:
      assert(!"invalid D3D11_BLEND_OP");
      return PIPE_BLEND_ADD;
   }
}

#define D3D11_COMPARISON_FUNC_CASE(n, m) case D3D11_COMPARISON_FUNC_##n: return PIPE_FUNC_##m
static INLINE unsigned
d3d11_to_pipe_func(D3D11_COMPARISON_FUNC func)
{
   switch (func) {
   D3D11_COMPARISON_FUNC_CASE(NEVER, NEVER);
   D3D11_COMPARISON_FUNC_CASE(ALWAYS, ALWAYS);
   D3D11_COMPARISON_FUNC_CASE(EQUAL, EQUAL);
   D3D11_COMPARISON_FUNC_CASE(NOT_EQUAL, NOTEQUAL);
   D3D11_COMPARISON_FUNC_CASE(LESS, LESS);
   D3D11_COMPARISON_FUNC_CASE(LESS_EQUAL, LEQUAL);
   D3D11_COMPARISON_FUNC_CASE(GREATER, GREATER);
   D3D11_COMPARISON_FUNC_CASE(GREATER_EQUAL, GEQUAL);
   default:
      assert(!"invalid D3D11_COMPARISON_FUNC");
      return PIPE_FUNC_NEVER;
   }
}
#undef D3D11_COMPARISON_FUNC_CASE

static INLINE unsigned
d3d11_to_pipe_cull_mode(D3D11_CULL_MODE mode)
{
    if (mode == D3D11_CULL_NONE)
        return PIPE_FACE_NONE;
    return (mode == D3D11_CULL_FRONT) ? PIPE_FACE_FRONT : PIPE_FACE_BACK;
}

static INLINE unsigned
d3d11_to_pipe_polygon_mode(D3D11_FILL_MODE mode)
{
   assert(mode == D3D11_FILL_WIREFRAME ||
          mode == D3D11_FILL_SOLID);
   return (mode == D3D11_FILL_SOLID) ?
      PIPE_POLYGON_MODE_FILL : PIPE_POLYGON_MODE_LINE;
}

static INLINE unsigned
d3d11_to_pipe_filter(struct pipe_sampler_state *ss, const D3D11_SAMPLER_DESC *pDesc)
{
   const D3D11_FILTER filter = pDesc->Filter;

   ss->min_img_filter = (filter & 0x10) ? PIPE_TEX_FILTER_LINEAR : PIPE_TEX_FILTER_NEAREST;
   ss->mag_img_filter = (filter & 0x04) ? PIPE_TEX_FILTER_LINEAR : PIPE_TEX_FILTER_NEAREST;

   ss->min_mip_filter = (filter & 0x01) ? PIPE_TEX_MIPFILTER_LINEAR : PIPE_TEX_MIPFILTER_NEAREST;
   if (pDesc->MaxLOD == 0.0f)
      ss->min_mip_filter = PIPE_TEX_MIPFILTER_NONE;

   ss->max_anisotropy = (filter & 0x40) ? pDesc->MaxAnisotropy : 0;

   ss->compare_mode = (filter & 0x80) ? PIPE_TEX_COMPARE_R_TO_TEXTURE : PIPE_TEX_COMPARE_NONE;
}

static INLINE unsigned
d3d11_to_pipe_prim(D3D11_PRIMITIVE prim)
{
   switch (prim) {
   case D3D11_PRIMITIVE_UNDEFINED: return PIPE_PRIM_POINTS;
   case D3D11_PRIMITIVE_POINT: return PIPE_PRIM_POINTS;
   case D3D11_PRIMITIVE_LINE: return PIPE_PRIM_LINE_STRIP;
   case D3D11_PRIMITIVE_TRIANGLE: return PIPE_PRIM_TRIANGLE_STRIP;
   case D3D11_PRIMITIVE_LINE_ADJ: return PIPE_PRIM_LINE_STRIP_ADJACENCY;
   case D3D11_PRIMITIVE_TRIANGLE_ADJ: return PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY;
   default:
      assert(prim >= D3D11_PRIMITIVE_1_CONTROL_POINT_PATCH &&
             prim <= D3D11_PRIMITIVE_32_CONTROL_POINT_PATCH);
      return PIPE_PRIM_PATCHES;
   }
}

static INLINE unsigned
d3d11_to_pipe_topology(D3D11_PRIMITIVE_TOPOLOGY prim)
{
#ifdef DEBUG
    switch (prim) {
    case D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED: return PIPE_PRIM_POINTS;
    case D3D11_PRIMITIVE_TOPOLOGY_POINTLIST: return PIPE_PRIM_POINTS;
    case D3D11_PRIMITIVE_TOPOLOGY_LINELIST: return PIPE_PRIM_LINES;
    case D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP: return PIPE_PRIM_LINE_STRIP;
    case D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST: return PIPE_PRIM_TRIANGLES;
    case D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: return PIPE_PRIM_TRIANGLE_STRIP;
    case D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ: return PIPE_PRIM_LINES_ADJACENCY;
    case D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ: return PIPE_PRIM_LINE_STRIP_ADJACENCY;
    case D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ: return PIPE_PRIM_TRIANGLES_ADJACENCY;
    case D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ: return PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY;
    default:
        assert(prim >= D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST &&
               prim <= D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST);
        return PIPE_PRIM_PATCHES;
    }
#else
    static const uint8_t map[] =
    {
       [D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED] = PIPE_PRIM_POINTS,
       [D3D11_PRIMITIVE_TOPOLOGY_POINTLIST] = PIPE_PRIM_POINTS,
       [D3D11_PRIMITIVE_TOPOLOGY_LINELIST] = PIPE_PRIM_LINES,
       [D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP] = PIPE_PRIM_LINE_STRIP,
       [D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST] = PIPE_PRIM_TRIANGLES,
       [D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP] = PIPE_PRIM_TRIANGLE_STRIP,
       [D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ] = PIPE_PRIM_LINES_ADJACENCY,
       [D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ] = PIPE_PRIM_LINE_STRIP_ADJACENCY,
       [D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ] = PIPE_PRIM_TRIANGLES_ADJACENCY,
       [D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ] = PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY
    };
    if (prim >= Elements(map))
       return PIPE_PRIM_PATCHES;
    return map[prim];
#endif
}

#define D3D11_STENCIL_OP_CASE(n, m) case D3D11_STENCIL_OP_##n: return PIPE_STENCIL_OP_##m
static INLINE unsigned
d3d11_to_pipe_stencil_op(D3D11_STENCIL_OP op)
{
    switch (op) {
    D3D11_STENCIL_OP_CASE(KEEP, KEEP);
    D3D11_STENCIL_OP_CASE(ZERO, ZERO);
    D3D11_STENCIL_OP_CASE(REPLACE, REPLACE);
    D3D11_STENCIL_OP_CASE(INVERT, INVERT);
    D3D11_STENCIL_OP_CASE(INCR, INCR_WRAP);
    D3D11_STENCIL_OP_CASE(DECR, DECR_WRAP);
    D3D11_STENCIL_OP_CASE(INCR_SAT, INCR);
    D3D11_STENCIL_OP_CASE(DECR_SAT, DECR);
    default:
       assert(!"invalid D3D11_STENCIL_OP");
       return PIPE_STENCIL_OP_KEEP;
    }
}
#undef D3D11_STENCIL_OP_CASE

static INLINE unsigned
d3d11_to_pipe_tex_address_mode(D3D11_TEXTURE_ADDRESS_MODE mode)
{
   switch (mode) {
   case D3D11_TEXTURE_ADDRESS_WRAP: return PIPE_TEX_WRAP_REPEAT;
   case D3D11_TEXTURE_ADDRESS_MIRROR: return PIPE_TEX_WRAP_MIRROR_REPEAT;
   case D3D11_TEXTURE_ADDRESS_CLAMP: return PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   case D3D11_TEXTURE_ADDRESS_BORDER: return PIPE_TEX_WRAP_CLAMP_TO_BORDER;
   case D3D11_TEXTURE_ADDRESS_MIRROR_ONCE: return PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;
   default:
      assert(!"invalid D3D11_TEXTURE_ADDRES");
      return PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   }
}
